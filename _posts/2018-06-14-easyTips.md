---
layout:     post
title:      常用技巧
summary:  
categories: Js
technique: true
---


### 数组

----- 数组去重>for循环给obj添加attr，for in遍历obj将属性值push进arr

----- 传参的情况下，取事件对象：`window.event || arguments[0].target`;


**数组插入**（同样是插入数据，第二种效率高很多）          

```javascript
var arr = [1,2,3,4,5];    
arr.push(6);   
arr[arr.length] = 6;   
arr.concat([6])   

var arr = [1,2,3,4,5];  
arr.unshift(0);   
[0].concat(arr);   （unshift修改了原来的数组，而concat返回一个新的数组）  

使用splice在数组中间插入是最高效的做法：
var items = ['one', 'two', 'three', 'four',"five"];
items.splice(items.length / 2, 0, 'hello');
```

**数组去重**  

```javascript
let arr = [1, 2, 2, 3];  
let set = new Set(arr);  
let newArr = Array.from(set); // Array.from方法可以将 Set 结构转为数组。  
console.log(newArr); // [1, 2, 3]  
```


**数组排序**

.sort() => 参数可选，规定排序顺序。必须是函数。  

[1,2,5,10].sort()   => [1, 10, 2, 5]   
 
正确排序：[1,2,5,10].sort((a, b) => a - b)    => => [1, 2, 5, 10 ]   

*根据数组对象中的某个属性值进行排序:sort方法接收一个函数作为参数，这里嵌套一层函数用来接收对象属性名，其他部分代码与正常使用sort方法相同。  

```javascript
var arr = [
  {name:"zopp",age:0},
  {name:"gpp",age:18},
  {name:"yjj",age:8}
];

function compare(property){
  return function(a,b){
  var value1 = a[property];
  var value2 = b[property];
  return value1 - value2;
  }
}
console.log(arr.sort(compare("age")))
```

**打乱数字数组的顺序**

```javascript
var arr = [1,2,3,4,5,6,7,'a','dsfs',8,9,'v'];    
arr.sort(function(){return Math.random()-0.5});
```

**生成从0到指定值的数字数组**

```javascript
var arr=[],length=4,i=1;
for(;arr.push(i++)<length;){}
console.log(arr)
```

**展开运算符**

```javascript
odd = [1, 3, 5 ];
const nums = [2 ,4 , 6, ...odd];
console.log(nums);           // [ 2, 4, 6, 1, 3, 5 ]
```

**复制数组**

```javascript
arr = [1, 2, 3, 4];
const arr2 = [...arr];
```

**插入随机位置**

```javascript
const odd = [1, 3, 5 ];
const nums = [2, ...odd, 4 , 6];
```

**剩余参数**

```javascript
const { a, b, ...z } = { a: 1, b: 2, c: 3, d: 4 };
console.log(a) // 1
console.log(b) // 2
console.log(z) // { c: 3, d: 4 }
```

**使用同一个方法处理数组和单一元素**

```javascript
function printUpperCase(words) {
    var elements = [].concat(words);
    for (var i = 0; i < elements.length; i++) {
        console.log(elements[i].toUpperCase());
    }
}
printUpperCase("cactus");
// => CACTUS
printUpperCase(["cactus", "bear", "potato"]);
// => CACTUS
// BEAR
// POTATO
```


### 日期

----- 字符串时间日期比较    new Date（"2017-02-02 13：23：23"）.getTime()

----- 方法封装

```javascript
changeTime(val){   // 日期格式转换
    if(val){
        return val.toLocaleDateString().replace(/\//g,"-");
    }else{
        return "";
    }
},
getDaysInMonth(year, month) { // 获取某年某月多少天
    var date = new Date(year, month, 1);
    return new Date(date.getTime() - 864e5).getDate();
},
getWeekStartAndEnd(date) { //获取当前周第一天和最后一天
    var date = new Date(date);
    //周几
    var week = date.getDay();
    var minusDay = week != 0 ? week - 1 : 6;
    //一天的毫秒数
    var millisecond = 1000 * 60 * 60 * 24;
    //获得当前周的第一天
    var currentWeekFirstDay = new Date(date.getTime() - (millisecond * minusDay));
    // //获得当前周的最后一天
    var currentWeekLastDay = new Date(currentWeekFirstDay.getTime() + (millisecond * 6));
    this.taskStartTime = this.changeTime(currentWeekFirstDay);
    this.taskEndTime = this.changeTime(currentWeekLastDay);
},

```


### 简写

**优雅的表示大数字**   
// All the below will evaluate to true  
1e0 === 1;   
1e1 === 10;   
1e2 === 100;  
1e3 === 1000;  
1e4 === 10000;   
1e5 === 100000;   
  

Longhand:const obj = { x:x, y:y };  
Shorthand:const obj = { x, y };   


**~~ 和 \|0**


Longhand:   Math.floor(4.9) === 4     //true;  //parseInt

Shorthand:  ~~4.9 === 4               //true

var foo = (12 / 4.13) \| 0;    //结果为2


**优化层叠的条件判断**

```javascript
原代码：
if (color) {
if (color === " black" ) {
     printBlackBackground();
} else if (color === " red" ) {
     printRedBackground();
} else if (color === " blue" ) {
     printBlueBackground();
} else if (color === " green" ) {
     printGreenBackground();
} else {
     printYellowBackground();
}
}
优化后：（还可以使用switch，但会给debug增加麻烦）
var colorObj = {
" black" : printBlackBackground,
" red" : printRedBackground,
" blue" : printBlueBackground,
" green" : printGreenBackground,
" yellow" : printYellowBackground
};
if (color && colorObj.hasOwnProperty(color)) {
     colorObj[color]();
}
```

hasOwnProperty()函数用于指示一个对象自身(不包括原型链)是否具有指定名称的属性。
如果有，返回true，否则返回false


**谨慎对待比较运算**

console.log(null == undefined) // true  
console.log(null === undefined) // false   

"abc" === "abc"           // true   
1 === 1 // true  

[1,2,3] === [1,2,3]       // false  
{a: 1} === {a: 1}         // false  
{} === {}                 // false   

Math.min() < Math.max()   // false   
因为Math.min() 返回 Infinity, 而 Math.max()返回 -Infinity·   


**检查属性是否在对象上**

```javascript
var myObject = {
     name: '@tips_js'
};
myObject.hasOwnProperty('name'); // true
'name' in myObject; // true
myObject.hasOwnProperty('valueOf'); // false, valueOf is inherited from the prototype chain
'valueOf' in myObject; // true
```

**toString() 方法可把一个逻辑值转换为字符串，并返回结果**   

number.toString(radix)

- 2- - 数字以二进制值显示
- 8 - 数字以八进制值显示
- 16 - 数字以十六进制值显示


**<< => 左移操作;二进制操作**

console.log( parseInt('1000000000000000000000000', 2) === (1 << 24))   //true  
console.log( Math.pow(2,24) === (1 << 24))   //true  
  
解释上面的1<<24的操作:其实是1左移24位。  
000000000000000000000001左移24位，变成了1000000000000000000000000  


**charAt()的替代品**

简化前："myString".charAt(0);  
简化后："myString"[0];           // 返回 'm'


### 插件

----- 安装sass模块

npm install node-sass --save-dev       
npm install sass-loader --save-dev

----- 安装less模块

npm install less --save-dev     
npm install less-loader --save-dev



### 解决端口被占用


1. Win+R  打开运行 ，输入cmd 打开命令行窗口   

2. 假设要查询端口8080被占用情况，在命令行下输入：`netstat  -aon|findstr  "8080" ` 
![](https://raw.githubusercontent.com/Selenamona/Selenamona.github.io/master/assets/images/easytip-port1.jpg)

3. 得到进程号 2996，继续输入命令： `tasklist|findstr  "2996"`   
![](https://raw.githubusercontent.com/Selenamona/Selenamona.github.io/master/assets/images/easytip-port2.jpg)

4. 得到进程映像名称  TNSLSNR.EXE   

5. Ctrl + Alt + delete 打开任务管理器，找到 名为 TNSLSNR.EXE的进程，右键，结束该进程

6. 这样端口被占用的问题就解决了


