---
layout: post
title: ECMAScript
summary:  
categories: Js
technique: true
---

### Number 

- parseInt() 用于任何数据类型转换成数值

- parseInt()  解析字符串，返回整数

- parseFloat()   解析字符串，返回浮点数
 
- 如果把 NaN 作为参数进行任何数学运算，结果也会是 NaN;
1. 可以使用内置函数 isNaN() 来判断一个变量是否为 NaN; `isNaN(NaN) = true`

- 内置函数 `isFinite()` 用于判断一个变量是否是一个有穷数。  
1. 如果判断类型为 Infinity、-Infinity、NaN，则返回false;   
2. isFinite("0") => true;    
3. 如果是纯数值类型的检测，则返回false：Number.isFinite("0");     

> 相关参考：[parseInt/parseFloat/Number](https://selenamona.github.io/2018/05/23/parseInt/)

###### Math

`Math.random()`                     ---------返回0-1之间的随机数    
`Math.max(num1, num2)`       ---------返回较大的数  (若num2>num1，输出num2)    
`Math.min(num1, num2)`        ---------返回较小的数   
`Math.abs(num)`                     ---------绝对值   
`Math.round(3.6)`           ---------四舍五入   
`Math.ceil(11.3)`           --------- 向上取整   =>12       
`Math.floor(11.8)`           ---------向下取整  =>11        
`Math.trunc(213.23)`             ---------整数部分  =>213           
`Math.PI`                     ---------π         
`Math.sqrt()`    ---------正平方根,如果参数是负值，返回NaN      
`Math.sign(x)`   ---------返回x的符号(1,-1,0)，表示x是否为正，负或零    
`Math.log10(x)`   ---------返回一个数字的以10对数     
`Math.log2(x)`    ---------返回一个数字的以2的对数    
`Math.pow(x,y)` ---------x的y次幂

###### Date

**获取日期**    
`d.getFullYear()`       ---------获取当前年份   
`d.getMonth()`          ---------获取当前月份（当前的月份从0开始）   
`d.getDate()`           ---------获取当前日期   
`d.getDay()`            ---------周几   
`d.getHours()`         ---------时   
`d.getMinutes()`        ---------分   
`d.getSeconds()`        ---------秒   
`d.getTime()`            ---------获取1970年到当前时间的毫秒数；【返回值每秒都在改变】    

**设置日期**   
`d.setFullYear(2012)`       ---------返回1970年1月1日到设定时间毫秒数   
`d.setMonth(9)`             ---------到当前年份指定月份的毫秒数[设置4，显示5月]    
`d.setDate()`             ---------到当前年份当前月份的指定日期的毫秒数    
`d.setHours()`    
`d.setMinutes()`   
`d.setSeconds()`    
`d.setTime()`              ---------指定时间（毫秒数）  【console.log(d.setTime(n))  => n】    

> 设置日期返回值：从1970年1月1日到设定时间毫秒数；
>
> Date.parse("2015-08-24")；获取1970年到设定时间的毫秒数；

### String 

**查询**   
`indexOf("abc")`      ---------查找字符串第一次出现的位置         
`lastIndexOf("abc")`      ---------查找字符串最后一次出现的位置,如果没找到返回-1                
`replace()`   ---------替换字符串 （返回修改后的字符串不对原字符串进行操作）                
      
     
**获取**    
`charAt(3)`        ---------获取下标为3的字符  （返回对应字符串）      
`charCodeAt(3)`       ---------获取下标为3的字符的Unicode码    
`String.fromCharCode(94)`        ---------编码转换成字符，适用于各种字符（英文、中文、标点等）   
`substring(start,end)`       ---------截取字符串;参数（开头下标，结尾下标）;注意结尾字符不截取   
`split(separator, howmany)`      ---------根据分隔符、拆分成数组；可以只写一个参数       

> separator (字符串!!! 不是下标) ：拆分位置（此位置上的项删除）；
>
> howmany：拆分后保留的项数（返回的数组的最大长度）；若此数大于项数，保留原数组；
>
> 返回值=> 数组； 
>
> 不加参数返回原数组；
>
> 如果空字符串("")用作separator,那么stringObject中的每个字符之间都会被分割。
   

**拼接**   
`concat()`       ---------连接字符串 （更适用于数组）    
       

**大小写**      
`toLowerCase()`    ---------全转小写     
`toUpperCase()`    ---------全转大写     


### 数组    
  
`a.push(item)`   ---------数组后插入item，返回数组新长度     
`a.unshift(item)`  ---------数组前插入item，返回数组新长度   
`a.pop()`  ---------数组后删除元素；删除并返回数组中最后一个元素    
`a.shift()`  ---------数组前删除元素；删除并返回数组中第一个元素     
`a.slice(start, end)`  ---------返回子数组，以 a[start] 开头，以 a[end] 前一个元素结尾      
`a.splice(start, num, new)`  ---------从 start 开始，删除num个元素，然后插入所有的new    
`a.sort()`  ---------排序     
`a.concat()`  ---------合并数组        
`a.reverse()`  ---------数组逆序（会更改原数组）      
`a.join(sep)`  ---------返回包含数组中所有元素的字符串，每个元素通过指定的 sep 分隔      
`a.toString()`   ---------返回包含数组中所有元素的字符串，元素间逗号分隔      
`a.toLocaleString()`  ---------返回包含数组中所有元素的字符串，元素间逗号分隔  

**toString()和toLocaleString()区别：**
```javascript
---四位数及以上 var a=1234;

a.toString()    // "1234"

a.toLocaleString()    // "1,234"

---日期格式 var sd=new Date();

sd.toLocaleString()    // "2017/2/15 上午11:21:31"

sd.toString()    // "Wed Feb 15 2017 11:21:31 GMT+0800 (CST)"
```   
     
        
**ES5新增**   
`a.indexOf(data,start)`   ---------返回当前数组中是否有某个数；若有返回下标，若无返回-1；  
`a.forEach()`   ---------遍历；参数：(value,index,arr)=>{}     
`a.map()`  ---------对数组每一项进行操作；返回值是一个操作之后的新数组，不改变原数组；  
`a.filter()`   ---------判断函数返回值；若为true，那么将这一项放入新数组，返回新数组；

                    
**相关参考**
[数组详细操作方法及解析合集/OBKoro1](https://juejin.im/user/58714f0eb123db4a2eb95372/posts)   


### ES7新特性 
    
1. 求幂运算符（**）
2. Array.prototype.includes()
3. 函数作用域中严格模式的变更


##### `Array.prototype.includes()`     

用法同indexOf();indexOff返回下标，includes返回true/false;   

```javascript
['a', 'b', 'c'].includes('a')   // true
['a', 'b', 'c'].indexOf('a')   // 0

// 注意NaN情况：  
let arr = [1, NaN, 2, 3];     
arr.indexOf(NaN)  // -1   
arr.includes(NaN)  // true    
```

##### 求幂运算符（**）

基本用法：3 ** 2     ---------9    
效果同：Math.pow(3, 2)    ---------9


### ES8新特性     
   

###### 异步函数（Async functions） 
异步函数声明：async function foo() {};    
异步函数表达式：const foo = async function () {};    
异步函数定义：let obj = { async foo() {} };    
异步箭头函数：const foo = async () => {};   

```javascript
function fetchTextByPromise() {
  return new Promise(resolve => {
    setTimeout(() => {
      resolve("es8");
    }, 2000);
  });
}
async function sayHello() {
  const externalFetchedText = await fetchTextByPromise();
  console.log(`Hello, ${externalFetchedText}`); // Hello, es8
}
sayHello();
 
console.log(1);
sayHello();
console.log(2);
 
// 调用结果
1 // immediately
2 // immediately
Hello, es8 // after 2 seconds
```

> 常见用法汇总：   

```javascript
//1. 处理单个异步结果
async function asyncFunc() {
    const result = await otherAsyncFunc();
    console.log(result);
}

//2. 顺序处理多个异步结果
async function asyncFunc() {
    const result1 = await otherAsyncFunc1();
    console.log(result1);
    const result2 = await otherAsyncFunc2();
    console.log(result2);
}

//3. 并行处理多个异步结果
async function asyncFunc() {
    const [result1, result2] = await Promise.all([
        otherAsyncFunc1(),
        otherAsyncFunc2()
    ]);
    console.log(result1, result2);
 }

//4. 处理错误
async function asyncFunc() {
    try {
        await otherAsyncFunc();
    } catch (err) {
        console.error(err);
    }
}
```

> 相关参考：[一次性让你懂async/await](https://juejin.im/post/5b1ffff96fb9a01e345ba704)
 
###### Object.entries() & Object.values() 

> `Object.entries()`    

如果一个对象是具有键值对的数据结构，则每一个键值对都将会编译成一个具有两个元素的数组，这些数组最终会放到一个数组中，返回一个二维数组。简言之，该方法会将某个对象的可枚举属性与值按照二维数组的方式返回。若目标对象是数组时，则会将数组的下标作为键值返回。                
```javascript
Object.entries({ one: 1, two: 2 }) => [['one', 1], ['two', 2]]     
Object.entries([1, 2]) => [['0', 1], ['1', 2]]    

//注意：键值对中，如果键的值是Symbol，编译时将会被忽略：   
Object.entries({ [Symbol()]: 1, two: 2 }) => [['two', 2]]    

//Object.entries()返回的数组的顺序与for-in循环保持一致，即如果对象的key值是数字，则返回值会对key值进行排序，返回的是排序后的结果：  
Object.entries({ 3: 'a', 4: 'b', 1: 'c' }) => [['1', 'c'], ['3', 'a'], ['4', 'b']]    

//使用Object.entries()，我们还可以进行对象属性的遍历：  
let obj = { one: 1, two: 2 };
for (let [k,v] of Object.entries(obj)) {
    console.log(`${JSON.stringify(k)}: ${JSON.stringify(v)}`);
}
//输出结果如下：
'one': 1
'two': 2
```

> `Object.values()`   
      
返回自己的键值对中属性的值。它返回的数组顺序，跟Object.entries()保持一致。  

``` javascript
Object.values({ one: 1, two: 2 }) // [1, 2]    
Object.values({ 3: 'a', 4: 'b', 1: 'c' }) // ['c', 'a', 'b']   
```  

###### 字符串填充 

`padStart`函数通过填充字符串的首部来保证字符串达到固定的长度；  
`padEnd`是填充字符串的尾部来保证字符串的长度的；  

```javascript
//两个参数：字符串目标长度和填充字段，其中第二个参数可以不填，默认情况下使用空格填充
'Vue'.padStart(10)       //' Vue'
'React'.padStart(10)       //' React'
'JavaScript'.padStart(10)       //'JavaScript'
//可以看出，多个数据如果都采用同样长度的padStart，相当于将呈现内容右对齐。

//可以指定字符串来代替空字符串:
'Vue'.padStart(10, '_*')       //'_*_*_*_Vue'
'React'.padStart(10, 'Hello')       //'HelloReact'
'JavaScript'.padStart(10, 'Hi')       //'JavaScript'
'JavaScript'.padStart(8, 'Hi')       //'JavaScript'
//从上面结果来看，填充函数只有在字符长度小于目标长度时才有效；   
//若字符长度已经等于或小于目标长度时，填充字符不会起作用；  
//目标长度如果小于字符串本身长度时，字符串也不会做截断处理，只会原样输出

//padEnd函数作用同padStart，只不过它是从字符串尾部做填充：
'Vue'.padEnd(10, '_*')       //'Vue_*_*_*_'
'React'.padEnd(10, 'Hello')       //'ReactHello'
'JavaScript'.padEnd(10, 'Hi')       //'JavaScript'
'JavaScript'.padEnd(8, 'Hi')       //'JavaScript'
```
###### Object.getOwnPropertyDescriptors() 

该方法会返回目标对象中所有属性的属性描述符，该属性必须是对象自己定义的，不能是从原型链继承来的。  
```javascript
let obj = {
    id: 1,
    name: 'test',
    get gender() {
        console.log('gender')
    },
    set grade(g) {
        console.log(g)
    }
}
Object.getOwnPropertyDescriptors(obj)

//输出结果为：
{
    gender: {
        configurable: true,
        enumerable: true,
        get: f gender(),
        set: undefined
    },
    grade: {
        configurable: true,
        enumerable: true,
        get: undefined,
        set: f grade(g)
    },
    id: {
        configurable: true,
        enumerable: true,
        value: 1,
        writable: true
    },
    name: {
        configurable: true,
        enumerable: true,
        value: 'test',
        writable: true
    }
}

//方法还提供了第二个参数，用来获取指定属性的属性描述符。
let obj = {
    id: 1,
    name: 'test',
    get gender() {
        console.log('gender')
    },
    set grade(g) {
        console.log(g)
    }
}
Object.getOwnPropertyDescriptors(obj, 'id')

//输出结果为：
{
    id: {
        configurable: true,
        enumerable: true,
        value: 1,
        writable: true
    }
}
```
> 由上述例子可知，该方法返回的描述符，会有两种类型：数据描述符、存取器描述符。返回结果中包含的键可能的值有：configurable、enumerable、value、writable、get、set。
> 
> 使用过Object.assign()的同学都知道，assign方法只能拷贝一个属性的值，而不会拷贝它背后的复制方法和取值方法。Object.getOwnPropertyDescriptors()主要是为了解决Object.assign()无法正确拷贝get属性和set属性的问题。  

```javascript
let obj = {
    id: 1,
    name: 'test',
    get gender() {
        console.log('gender')
    }
}
Object.assign(obj)

//输出结果为：
{
    gender: undefined
    id: 1,
    name: 'test'
}

//Object.getOwnPropertyDescriptors方法配合Object.defineProperties方法，就可以实现正确拷贝。

let obj = {
    id: 1,
    name: 'test',
    get gender() {
        console.log('gender')
    }
}
let obj1 = {}
Object.defineProperties(obj1, Object.getOwnPropertyDescriptors(obj))
Object.getOwnPropertyDescriptors(obj1)

//输出结果为：
{
    gender: {
        configurable: true,
        enumerable: true,
        get: f gender(),
        set: undefined
    },
    id: {
        configurable: true,
        enumerable: true,
        value: 1,
        writable: true
    },
    name: {
        configurable: true,
        enumerable: true,
        value: 'test',
        writable: true
    }
}
```

更多Object.getOwnPropertyDescriptors的使用细则，可参见[阮一峰的博客文章](http://es6.ruanyifeng.com/#docs/object#Object-getOwnPropertyDescriptors)

###### 共享内存和原子（Shared memory and atomics） 


共享内存允许多个线程并发读写数据，而原子操作则能够进行并发控制，确保多个存在竞争关系的线程顺序执行。本部分则介绍了新的构造器 SharedArrayBuffer 与包含静态方法的命名空间对象 Atomics。Atomic 对象类似于 Math，我们无法直接创建其实例，而只能使用其提供的静态方法：

add /sub - 增加或者减去某个位置的某个值

and / or /xor - 进行位操作

load - 获取值

###### 函数参数列表与调用中的尾部逗号 

该特性允许我们在定义或者调用函数时添加尾部逗号而不报错。

```javascript
let foo = function (a,b,c,) {
    console.log('a:', a)
    console.log('b:', b)
    console.log('c:', c)
}
foo(1, 3, 4, )

//输出结果为：
a: 1
b: 3
c: 4
```




### More
****************************************

[10分钟学会ES7+ES8 / 大转转FE](https://www.cnblogs.com/zhuanzhuanfe/p/7493433.html)   

[ECMAScript 6 入门 / 阮一峰](http://es6.ruanyifeng.com/)

[ECMAScript 2015 功能概述](https://www.babeljs.cn/learn-es2015/)

[Javascript的8张思维导图](https://selenamona.github.io/2018/06/08/JS-mind-map/)

[js系列](https://github.com/mqyqingfeng/Blog)

[悟透JavaScript](http://www.cnblogs.com/leadzen/archive/2008/02/25/1073404.html)

[js 模块化开发](https://blog.csdn.net/qq_33915096/article/details/50965101)

[你不知道的JavaScript](http://www.cnblogs.com/strick/category/872767.html)

[彻底理解js中this的指向](http://www.cnblogs.com/pssp/p/5216085.html)

[对Js赋值运算的新认识](https://segmentfault.com/a/1190000002965140)

[数组方法汇总](https://segmentfault.com/a/1190000004201677)

[Front-End-Basics](https://github.com/qiqihaobenben/Front-End-Basics)