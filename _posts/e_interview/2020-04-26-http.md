---
layout:     post
title:      http
summary:     
categories: http
technique: true
---

## | HTTP协议简介

《图解HTTP》一文中这样描述HTTP在网络中的地位：
> Web使用一种名为HTTP（HyperText Transfer Protocol，超文本传输协议）的协议作为规范，完成从客户端到服务器等一系列运作流程。而协议是指规则的约定。可以说，Web是建立在HTTP协议上通信的。

HTTP最初的目的是为了让研究者共享知识信息，所以它的主要作用就是文档传输，它是一种用于传输文档的协议。
HTTP是不保存状态的协议，既无状态协议，协议本身对于请求或响应之间的通信状态不进行保存，因此连接双方不能知晓对方当前的身份和状态。

TCP/IP 协议分层模型:
<img src="/assets/images/http.png" width="400">


在传输层有两个性质不同的协议：TCP（Transmission Control Protocol，传输控制协议）和UDP（User Data Protocol，用户数据报协议）。

TCP协议是全双工的，即发送数据和接收数据是同步进行的，就好像我们打电话一样，说话的同时也能听见。TCP协议在建立和断开连接时有三次握手和四次挥手，因此在传输的过程中更稳定可靠但同时就没UDP那么高效了。

UDP协议是面向无连接的，也就是说在正式传递数据之前不需要先建立连接。UDP 协议不保证有序且不丢失的传递到对端，也就是说不够稳定，但也正因如此，UDP协议比TCP更加高效和轻便。

Cookie 会根据响应报文中的 Set-Cookie 字段来通知客户端自动保存 Cookie。下次请求时会自动发送 Cookie，服务器会比对数据得到状态结果。

<img src="/assets/images/http_cookie.png" width="400">

## | HTTPS 

HTTPS 是 HTTP 建立在 SSL/TLS 安全协议上的。

在 iOS 中，客户端本地会存放着 CA 证书，在HTTPS 请求时，会首先像服务器索要公钥，获得公钥后会使用本地 CA 证书验证公钥的正确性，然后通过正确的公钥加密信息发送给服务器，服务器会使用私钥解密信息。 

***SSL协议的握手过程***

开始加密通信之前，客户端和服务器首先必须建立连接和交换参数，这个过程叫做握手。

1. 客户端发出请求（ClientHello）：客户端给出协议版本号、一个客户端生成的随机数（Client random），以及客户端支持的加密方法。 
2. 服务器回应（SeverHello）：服务器确认双方使用的加密方法，并给出数字证书、以及一个服务器生成的随机数（Server random）。
3. 客户端回应：客户端确认数字证书有效，然后生成一个新的随机数（Premaster secret），并使用数字证书中的公钥，加密这个随机数，发给服务器。
4. 服务器使用自己的私钥，获取客户端发来的随机数（即Premaster secret）。
5. 客户端和服务器根据约定的加密方法，使用前面的三个随机数，生成"对话密钥"（session key），用来加密接下来的整个对话过程。


👉握手阶段有三点需要注意：

（1）生成对话密钥一共需要三个随机数。
（2）握手之后的对话使用"对话密钥"加密（对称加密），服务器的公钥和私钥只用于加密和解密"对话密钥"（非对称加密），无其他作用。
（3）服务器公钥放在服务器的数字证书之中。


## | TCP 三次握手

主机 A 相与主机 B 建立连接，主机 A 会首先发送一个 SYN 包给主机 B。主机 B 会返回 确认应答 ACK 或者否定应答 NACK。（如果这时主机 A 长时间没有收到主机 B 的应答，主机 A 会重发 SYN 包给主机 B，实现了重发数据包的功能。）当主机 B 发送 ACK 给主机 A 后，主机 A 也会发送一个 ACK 包给主机 B，这时建立连接。

***为什么不是两次握手？***
两次握手就建立连接，假如主机 A 发送的 SYN 因网络问题迟迟没有到达主机 B，这时候会重发另一个 SYN 包给 B，当 A 接受到 B 的 ACK 包时建立连接。这时如果第一个 SYN 到达 B 时，主机 B 会认为主机 A 希望再次建立连接，会返回一个 ACK 包给 A。当 A 收到 ACK 时会抛弃掉这个包，因为 A 并不想建立连接，这时主机 B 认为连接已经建立，会一直等待主机 A 发送数据，这样会导致主机 B 的性能损耗。 

***四次握手断开连***
主机 A 发送 FIN（请求切断连接），主机 B 收到后回复 ACK 和 FIN 包，主机 A 收到主机 B 的 FIN 和 ACK 后发送 ACK 包


## | nginx 反向代理解决跨域问题

前端在使用 vue-cli 这种脚手架工具进行开发时，经常会遇到跨域的问题，因为项目自身启动本地服务是需要占用一个端口（如 http://localhost:8080）的，所以必然会产生跨域的问题（因为本地服务端口和服务端接口地址不是同源）。在使用webpack做构建工具的项目中，经常会使用proxyTable代理实现跨域（具体实现自行百度）。之所以出现跨域是因为浏览器有同源策略的限制，但服务器是没有的同源策略的限制的。当我们本地服务（假设域名：http://localhost:8080）要请求目标服务器（假设域名：target.com）的资源的时候，我们不直接请求 target.com，而是请求本地服务自身 http://localhost:8080（这时是同源请求，不存在跨域），本地代理服务再将接口转发给 target.com（注意这时候是两个服务器直接的通信了，而不是客户端和服务器的通信，所以更不存在跨域），本地服务获取到目标服务器的响应数据之后通过再代理伪装成本地服务请求的返回值返回给客户端。

> 本地服务在浏览器向本地服务发起请求 --> 本地代理转发 --> 目标服务器 --> 响应数据后通过代理伪装成本地服务器请求的返回值 --> 浏览器接受到目标服务器的数据



```javascript
// vue-cli反向代理配置如下：
//vue.config.js
  devServer: {
    port: 8080, // 配置端口
    open: true, // 项目启动自动开启浏览器
    compress: true, // 开启压缩
    overlay: { // 设置让浏览器 overlay 同时显示警告和错误
      warnings: true,
      errors: true
    },
    // 设置请求反向代理
    proxy: {
      '/api': { // 要代理的接口的匹配字符
        target: process.env.BASE_URL, // 接口域名
        secure: false,
        changeOrigin: true
      }
    }
  },
```

复制代码需要注意如果要用反向代理，则在 axios 配置的时候，请求baseURL必须设置为字符串'/'，否则 proxy 会匹配不到'/api'导致代理失败。


[阮一峰-图解SSL/TLS协议](http://www.ruanyifeng.com/blog/2014/09/illustration-ssl.html)
[前端基础篇之HTTP协议&安全防范](https://juejin.im/post/5cd0438c6fb9a031ec6d3ab2)
 